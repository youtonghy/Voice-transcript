const { app, BrowserWindow, ipcMain, Menu, dialog } = require('electron');
const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

let mainWindow;
let settingsWindow;
let mediaTranscribeWindow;
// Pythonè¿›ç¨‹ç®¡ç†
let pythonProcess;
let mediaTranscribeProcess;
let pythonBuffer = ''; // ç”¨äºç¼“å­˜ä¸å®Œæ•´çš„JSONæ¶ˆæ¯
let pythonReady = false;
let pendingMessages = []; // ç¼“å­˜å¾…å‘é€çš„æ¶ˆæ¯
let restartingPython = false; // é˜²æ­¢é‡å¤é‡å¯
let restartAfterUserStopPending = false; // ç”¨æˆ·æ‰‹åŠ¨åœæ­¢å½•éŸ³åå¾…é‡å¯æ ‡è®°
let config = {
  openai_api_key: '',
  openai_base_url: '',
  enable_translation: true,
  translate_language: 'ä¸­æ–‡',
  theater_mode: false
};

// é…ç½®æ–‡ä»¶è·¯å¾„ï¼šå¼€å‘ç¯å¢ƒä½¿ç”¨é¡¹ç›®ç›®å½•ï¼›æ‰“åŒ…åä½¿ç”¨ç”¨æˆ·ç›®å½?
const isPackaged = app.isPackaged;
const userDataPath = app.getPath('userData');
const configPath = isPackaged
  ? path.join(userDataPath, 'config.json')
  : path.join(__dirname, 'config.json');

// åŠ è½½é…ç½®
function loadConfig() {
  try {
    if (fs.existsSync(configPath)) {
      const data = fs.readFileSync(configPath, 'utf8');
      config = { ...config, ...JSON.parse(data) };
    }
  } catch (error) {
    console.error('Failed to load config:', error);
  }
}

// ä¿å­˜é…ç½®
function saveConfig() {
  try {
    // ç¡®ä¿ç›®å½•å­˜åœ¨ï¼ˆæ‰“åŒ…ç¯å¢ƒä¸‹åœ¨ç”¨æˆ·æ•°æ®ç›®å½•ï¼‰
    const dir = path.dirname(configPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
  } catch (error) {
    console.error('Failed to save config:', error);
  }
}

// å¤„ç†Pythonè¿›ç¨‹è¾“å‡ºçš„å‡½æ•?
function processPythonOutput(data) {
  const dataStr = data.toString('utf8');
  console.log('Python raw output:', dataStr);
  
  // å°†æ–°æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
  pythonBuffer += dataStr;
  
  // å°è¯•æå–å®Œæ•´çš„JSONæ¶ˆæ¯
  const messages = [];
  let braceCount = 0;
  let inString = false;
  let escapeNext = false;
  let currentMessage = '';
  
  for (let i = 0; i < pythonBuffer.length; i++) {
    const char = pythonBuffer[i];
    currentMessage += char;
    
    if (escapeNext) {
      escapeNext = false;
      continue;
    }
    
    if (char === '\\') {
      escapeNext = true;
      continue;
    }
    
    if (char === '"') {
      inString = !inString;
      continue;
    }
    
    if (!inString) {
      if (char === '{') {
        braceCount++;
      } else if (char === '}') {
        braceCount--;
        if (braceCount === 0) {
          // æ‰¾åˆ°å®Œæ•´çš„JSONæ¶ˆæ¯
          messages.push(currentMessage.trim());
          currentMessage = '';
        }
      }
    }
  }
  
  // æ›´æ–°ç¼“å†²åŒºï¼Œä¿ç•™æœªå®Œæˆçš„æ¶ˆæ¯
  pythonBuffer = currentMessage;
  
  // å¤„ç†æå–å‡ºçš„å®Œæ•´æ¶ˆæ¯
  messages.forEach(messageStr => {
    if (messageStr) {
      try {
        const message = JSON.parse(messageStr);
        console.log('Parsed Python message:', message);
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯å¯åŠ¨å®Œæˆæ¶ˆæ¯
        if (message.type === 'log' && message.message === 'è½¬å†™æœåŠ¡å·²å¯åŠ¨ï¼Œç­‰å¾…å‘½ä»¤...') {
          pythonReady = true;
          console.log('Python service is ready; flushing pending messages.');
          
          // å‘é€æ‰€æœ‰å¾…å‘é€çš„æ¶ˆæ¯
          while (pendingMessages.length > 0) {
            const pendingMessage = pendingMessages.shift();
            sendToPythonDirect(pendingMessage);
          }
        }
        
        if (mainWindow) {
          mainWindow.webContents.send('python-message', message);
        }

        // æ£€æµ‹å½•éŸ³åœæ­¢äº‹ä»¶ï¼Œç”¨äºæŒ‰éœ€é‡å¯æœåŠ¡
        if (message.type === 'recording_stopped') {
          console.log('Detected recording has stopped.');
          if (restartAfterUserStopPending) {
            console.log('User requested restart after stop. Restarting gracefully...');
            restartAfterUserStopPending = false;
            restartPythonServiceAfterStop();
          }
        }
      } catch (error) {
        console.error('JSON parse failed:', error);
        console.error('Raw message:', messageStr);
        
        // å‘é€åŸå§‹æ¶ˆæ¯ä½œä¸ºæ—¥å¿?
if (mainWindow) {
          mainWindow.webContents.send('python-message', {
            type: 'log',
            level: 'warning',
            message: `Pythonè¾“å‡ºè§£æå¤±è´¥: ${messageStr}`,
            timestamp: new Date().toISOString()
          });
        }
      }
    }
  });
}

// ç›´æ¥å‘é€æ¶ˆæ¯åˆ°Pythonï¼ˆä¸æ£€æŸ¥çŠ¶æ€ï¼‰
function sendToPythonDirect(message) {
  try {
    const jsonMessage = JSON.stringify(message) + '\n';
    console.log('Send to Python:', jsonMessage.trim());
    pythonProcess.stdin.write(jsonMessage);
    return true;
  } catch (error) {
    console.error('Failed to send message directly:', error);
    return false;
  }
}

function createWindow() {
  try {
    mainWindow = new BrowserWindow({
      width: 1000,
      height: 700,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js')
      },
      icon: path.join(__dirname, 'assets', 'icon.png'),
      title: 'Speech Transcription & Translation',
      show: false // å…ˆä¸æ˜¾ç¤ºï¼ŒåŠ è½½å®Œæˆåå†æ˜¾ç¤?
});

    mainWindow.loadFile('index.html');

    // ç­‰å¾…é¡µé¢å‡†å¤‡å°±ç»ªåå†æ˜¾ç¤ºçª—å£
    mainWindow.once('ready-to-show', () => {
      mainWindow.show();
      console.log('Window shown');
    });

    // å¼€å‘æ¨¡å¼ä¸‹æ‰“å¼€å¼€å‘è€…å·¥å…?
if (process.argv.includes('--dev')) {
      mainWindow.webContents.openDevTools();
    }

    mainWindow.on('closed', () => {
      mainWindow = null;
    });

    // æ·»åŠ é”™è¯¯å¤„ç†
    mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription) => {
      console.error('Page load failed:', errorCode, errorDescription);
    });

  } catch (error) {
    console.error('Error creating window:', error);
    app.quit();
  }
}

function createSettingsWindow() {
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  settingsWindow = new BrowserWindow({
    width: 500,
    height: 600,
    parent: mainWindow,
    modal: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    title: 'Settings',
    resizable: false
  });

  settingsWindow.loadFile('settings.html');

  settingsWindow.on('closed', () => {
    settingsWindow = null;
  });
}

function createMediaTranscribeWindow() {
  if (mediaTranscribeWindow) {
    mediaTranscribeWindow.focus();
    return;
  }

  mediaTranscribeWindow = new BrowserWindow({
    width: 1100,
    height: 720,
    parent: mainWindow,
    modal: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    title: 'Media Transcription',
    resizable: true
  });

  mediaTranscribeWindow.loadFile('media-transcribe.html');

  mediaTranscribeWindow.on('closed', () => {
    mediaTranscribeWindow = null;
  });
}

function startPythonService() {
  console.log('startPythonService called');
  
  // å·²æœ‰è¿è¡Œä¸­çš„æœåŠ¡åˆ™ä¸é‡å¤å¯åŠ¨ï¼Œä¿æŒå•å®ä¾‹
  if (pythonProcess) {
    console.log('Transcription service already running; skip start.');
    return true;
  }

  // é‡ç½®çŠ¶æ€?
pythonReady = false;
  pythonBuffer = '';
  pendingMessages = [];

  console.log('Starting transcription service...');
  const userCwd = isPackaged ? userDataPath : __dirname;
  
  // ä¼˜å…ˆå¯»æ‰¾å·²ç¼–è¯‘çš„exeæ–‡ä»¶
  let servicePath = null;
  let useSystemPython = false;
  
  // æŒ‰ä¼˜å…ˆçº§æœç´¢å¯æ‰§è¡Œæ–‡ä»?
const candidates = [];
  
  if (isPackaged) {
    // æ‰“åŒ…åç¯å¢ƒï¼šä»resourcesç›®å½•æŸ¥æ‰¾
    candidates.push(path.join(process.resourcesPath, 'python', 'transcribe_service.exe'));
  } else {
    // å¼€å‘ç¯å¢ƒï¼šä¼˜å…ˆä½¿ç”¨å·²ç¼–è¯‘çš„exe
    candidates.push(path.join(__dirname, 'dist-python', 'win', 'transcribe_service.exe'));
    candidates.push(path.join(__dirname, 'dist', 'transcribe_service.exe'));
  }

  // æŸ¥æ‰¾å¯ç”¨çš„exeæ–‡ä»¶
  for (const candidate of candidates) {
    if (fs.existsSync(candidate)) {
      servicePath = candidate;
      console.log('Found transcription service executable:', servicePath);
      break;
    }
  }

  // å¦‚æœæ²¡æœ‰æ‰¾åˆ°exeæ–‡ä»¶ï¼Œæ‰è€ƒè™‘ä½¿ç”¨Pythonè„šæœ¬ï¼ˆä»…åœ¨å¼€å‘æ¨¡å¼ä¸‹ï¼?
if (!servicePath && !isPackaged) {
    const pythonScript = path.join(__dirname, 'transcribe_service.py');
    if (fs.existsSync(pythonScript)) {
      // åªæœ‰åœ¨é…ç½®ä¸­æ˜ç¡®æŒ‡å®šPythonè·¯å¾„æ—¶æ‰ä½¿ç”¨è„šæœ¬æ¨¡å¼
      const configPythonPath = config.python_path;
      if (configPythonPath) {
        servicePath = configPythonPath;
        useSystemPython = true;
        console.log('Using configured Python path to run script:', configPythonPath, pythonScript);
      } else {
        console.warn('Executable not found and Python path is not set. Configure Python path in Settings or run npm run build:py:win to build the service.');
        if (mainWindow) {
          mainWindow.webContents.send('python-message', {
            type: 'log',
            level: 'error',
            message: 'è½¬å†™æœåŠ¡ä¸å¯ç”¨ï¼šæœªæ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸”æœªé…ç½®Pythonè·¯å¾„ã€‚è¯·åœ¨è®¾ç½®ä¸­é…ç½®Pythonè·¯å¾„æˆ–é‡æ–°ç¼–è¯‘æœåŠ¡ã€?,
            timestamp: new Date().toISOString()
          });
        }
        return false;
      }
    }
  }

  if (!servicePath) {
    const errorMsg = 'æ— æ³•å¯åŠ¨è½¬å†™æœåŠ¡ï¼šæœªæ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶ã€‚è¯·è¿è¡Œ npm run build:py:win ç¼–è¯‘æœåŠ¡ã€?;
    console.error(errorMsg);
    if (mainWindow) {
      mainWindow.webContents.send('python-message', {
        type: 'log',
        level: 'error',
        message: errorMsg,
        timestamp: new Date().toISOString()
      });
    }
    return false;
  }
  
  try {
    let spawnCmd, spawnArgs;
    
    if (useSystemPython) {
      spawnCmd = servicePath;
      spawnArgs = [path.join(__dirname, 'transcribe_service.py')];
    } else {
      spawnCmd = servicePath;
      spawnArgs = [];
    }
    
    console.log('Start transcription service:', spawnCmd, spawnArgs);
    
    // è®¾ç½®ç¯å¢ƒå˜é‡
    const processEnv = { 
      ...process.env, 
      PYTHONUNBUFFERED: '1',
      PYTHONIOENCODING: 'utf-8'
    };
    
    // å¦‚æœæ˜¯å¼€å‘æ¨¡å¼ï¼Œå¯ç”¨è°ƒè¯•æ—¥å¿—
    if (process.argv.includes('--dev') || process.env.NODE_ENV === 'development') {
      processEnv.ELECTRON_DEBUG = '1';
      console.log('Debug mode enabled; Python service will output verbose logs.');
    }
    
    pythonProcess = spawn(spawnCmd, spawnArgs, {
      stdio: ['pipe', 'pipe', 'pipe'],
      cwd: userCwd,
      env: processEnv
    });

    console.log('Transcription service started, PID:', pythonProcess.pid);

    // ä½¿ç”¨æ–°çš„è¾“å‡ºå¤„ç†å‡½æ•°
    pythonProcess.stdout.on('data', processPythonOutput);

    pythonProcess.stderr.on('data', (data) => {
      const errorOutput = data.toString('utf8');
      console.error('Python stderr:', errorOutput);

      // åœ¨è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæ˜¾ç¤ºæ›´è¯¦ç»†çš„stderrä¿¡æ¯
      if (processEnv.ELECTRON_DEBUG === '1') {
        console.log('Python debug:', errorOutput);
      }

      if (mainWindow) {
        mainWindow.webContents.send('python-message', {
          type: 'log',
          level: 'error',
          message: `Pythoné”™è¯¯: ${errorOutput.trim()}`,
          timestamp: new Date().toISOString()
        });
      }
    });

    pythonProcess.on('error', (error) => {
      console.error('Failed to spawn Python process:', error);
      pythonReady = false;
      if (mainWindow) {
        mainWindow.webContents.send('python-message', {
          type: 'log',
          level: 'error',
          message: `Pythonè¿›ç¨‹å¯åŠ¨å¤±è´¥: ${error.message}`,
          timestamp: new Date().toISOString()
        });
      }
      pythonProcess = null;
    });

    pythonProcess.on('close', (code, signal) => {
      console.log(Python process exited, code: , signal: );
      pythonReady = false;
      if (mainWindow) {
        mainWindow.webContents.send('python-message', {
          type: 'log',
          level: 'warning',
          message: `è½¬å†™æœåŠ¡å·²åœæ­?(é€€å‡ºä»£ç ? ${code}, ä¿¡å·: ${signal})`,
          timestamp: new Date().toISOString()
        });
      }
      pythonProcess = null;
    });

    pythonProcess.on('spawn', () => {
      console.log('Service process spawned; waiting for initialization...');
      if (mainWindow) {
        mainWindow.webContents.send('python-message', {
          type: 'log',
          level: 'info',
          message: 'è½¬å†™æœåŠ¡è¿›ç¨‹å·²å¯åŠ?,
          timestamp: new Date().toISOString()
        });
      }

      // Send initial config immediately; will be queued if not ready\n
console.log('Sending initial config to service (immediate):', config);
      sendToPython({ type: 'update_config', config });
    });

    return true;
  } catch (error) {
    console.error('Failed to start transcription service:', error);
    pythonReady = false;
    if (mainWindow) {
      mainWindow.webContents.send('python-message', {
        type: 'log',
        level: 'error',
        message: `å¯åŠ¨è½¬å†™æœåŠ¡å¤±è´¥: ${error.message}`,
        timestamp: new Date().toISOString()
      });
    }
    return false;
  }
}

function sendToPython(message) {
  console.log('Preparing to send message to transcription service:', message);

  if (!pythonProcess) {
    console.error('Service process is not running; cannot send message');
    if (mainWindow) {
      mainWindow.webContents.send('python-message', {
        type: 'log',
        level: 'error',
        message: 'è½¬å†™æœåŠ¡æœªå¯åŠ¨ï¼Œæ— æ³•å‘é€å‘½ä»?,
        timestamp: new Date().toISOString()
      });
    }
    return false;
  }

  if (!pythonProcess.stdin) {
    console.error('Service process stdin is not available');
    if (mainWindow) {
      mainWindow.webContents.send('python-message', {
        type: 'log',
        level: 'error',
        message: 'è½¬å†™æœåŠ¡é€šä¿¡ç®¡é“ä¸å¯ç”?,
        timestamp: new Date().toISOString()
      });
    }
    return false;
  }

  // å¦‚æœPythonæœåŠ¡æœªå°±ç»ªï¼Œå°†æ¶ˆæ¯åŠ å…¥å¾…å‘é€é˜Ÿåˆ?
if (!pythonReady) {
    console.log('Python service not ready; enqueue message.');
    pendingMessages.push(message);
    return true;
  }

  return sendToPythonDirect(message);
}

// ç”¨æˆ·æ‰‹åŠ¨åœæ­¢å½•éŸ³åè§¦å‘çš„ä¼˜é›…é‡å¯é€»è¾‘
function restartPythonServiceAfterStop() {
  if (!pythonProcess) {
    console.log('Service process not found; starting a new instance.');
    startPythonService();
    return;
  }

  if (restartingPython) {
    console.log('Restart in progress; ignoring duplicate trigger');
    return;
  }

  restartingPython = true;
  try {
    console.log('Sending shutdown command for graceful exit.');
    // å°è¯•ä¼˜é›…å…³é—­
    sendToPythonDirect({ type: 'shutdown' });
  } catch (e) {
    console.warn('Failed to send shutdown command; will terminate instead:', e.message);
  }

  let closed = false;
  const onClose = () => {
    if (closed) return;
    closed = true;
    console.log('Old service exited; preparing to restart');
    pythonProcess = null;
    setTimeout(() => {
      const ok = startPythonService();
      restartingPython = false;
      console.log('Restart result:', ok);
    }, 500);
  };

  // ä¸€æ¬¡æ€§ç›‘å¬å…³é—?
const closeHandler = (code, signal) => {
    console.log('Received service close event (restart flow):', code, signal);
    if (pythonProcess) {
      pythonProcess.removeListener('close', closeHandler);
    }
    onClose();
  };
  if (pythonProcess) {
    pythonProcess.once('close', closeHandler);
  }

  // è¶…æ—¶å¼ºåˆ¶å…³é—­
  setTimeout(() => {
    if (!closed) {
      console.warn('Graceful close timed out; force killing process');
      try {
        pythonProcess && pythonProcess.kill();
      } catch (e) {}
    }
  }, 5000);
}

// IPCäº‹ä»¶å¤„ç†
ipcMain.handle('start-recording', () => {
  console.log('Received start-recording request');
  const result = sendToPython({ type: 'start_recording' });
  console.log('Start-recording command sent:', result);
  return result;
});

ipcMain.handle('stop-recording', () => {
  console.log('Received stop-recording request');
  restartAfterUserStopPending = true; // æ ‡è®°ç”¨æˆ·æ‰‹åŠ¨åœæ­¢ï¼Œå½•éŸ³åœæ­¢åå°†é‡å¯æœåŠ?
const result = sendToPython({ type: 'stop_recording' });
  console.log('Stop-recording command sent:', result);
  return result;
});

ipcMain.handle('get-config', () => {
  console.log('Get-config requested. Current config:', config);
  return config;
});

// æä¾›åç«¯æœåŠ¡çŠ¶æ€ç»™æ¸²æŸ“è¿›ç¨‹ï¼Œé¿å…é¡µé¢åˆ‡æ¢åè¯¯åˆ¤ä¸ºâ€œç­‰å¾…æœåŠ¡å¯åŠ¨â€?
ipcMain.handle('get-service-status', () => {
  return {
    running: !!pythonProcess,
    ready: pythonReady,
    pid: pythonProcess ? pythonProcess.pid : null
  };
});

ipcMain.handle('save-config', (event, newConfig) => {
  console.log('Received save-config request:', newConfig);
  config = { ...config, ...newConfig };
  saveConfig();
  console.log('Config saved (will take effect on next start):', config);
  const result = sendToPython({ type: 'update_config', config });
  // Changes will take effect on next start (not sent to backend)
  return true;
});

ipcMain.handle('open-settings', () => {
  console.log('Open Settings requested (separate window)');
  createSettingsWindow();
});

ipcMain.handle('open-media-transcribe', () => {
  console.log('Open Media Transcription requested (separate window)');
  createMediaTranscribeWindow();
});

ipcMain.handle('test-python', async (event, pythonPath) => {
  console.log('Received Python test request:', pythonPath);

  // å¦‚æœæ²¡æœ‰æä¾›Pythonè·¯å¾„ï¼Œæç¤ºç”¨æˆ·è¿™æ˜¯å¯é€‰çš„
  if (!pythonPath) {
    return {
      success: true,
      version: 'ä½¿ç”¨å·²ç¼–è¯‘çš„è½¬å†™æœåŠ¡ï¼Œæ— éœ€Pythonç¯å¢ƒ',
      message: 'åº”ç”¨å°†ä½¿ç”¨é¢„ç¼–è¯‘çš„è½¬å†™æœåŠ¡ï¼ŒPythonç¯å¢ƒé…ç½®æ˜¯å¯é€‰çš„ã€?
    };
  }

  return new Promise((resolve) => {
    const testCmd = pythonPath;
    const testProcess = spawn(testCmd, ['--version'], {
      stdio: ['pipe', 'pipe', 'pipe'],
      env: {
        ...process.env,
        PYTHONIOENCODING: 'utf-8'
      }
    });

    let output = '';
    let error = '';

    testProcess.stdout.on('data', (data) => {
      output += data.toString('utf8');
    });

    testProcess.stderr.on('data', (data) => {
      error += data.toString('utf8');
    });

    testProcess.on('close', (code) => {
      if (code === 0) {
        const version = output.trim() || error.trim(); // æœ‰äº›Pythonç‰ˆæœ¬è¾“å‡ºåˆ°stderr
        resolve({
          success: true,
          version: version,
          message: 'Pythonç¯å¢ƒå¯ç”¨ï¼Œä½†åº”ç”¨å°†ä¼˜å…ˆä½¿ç”¨é¢„ç¼–è¯‘æœåŠ¡ã€?
        });
      } else {
        resolve({
          success: false,
          error: error.trim() || `è¿›ç¨‹é€€å‡ºä»£ç ? ${code}`,
          message: 'Pythonæµ‹è¯•å¤±è´¥ï¼Œä½†ä¸å½±å“ä½¿ç”¨é¢„ç¼–è¯‘çš„è½¬å†™æœåŠ¡ã€?
        });
      }
    });

    testProcess.on('error', (err) => {
      resolve({
        success: false,
        error: err.message,
        message: 'Pythonä¸å¯ç”¨ï¼Œä½†åº”ç”¨å°†ä½¿ç”¨é¢„ç¼–è¯‘çš„è½¬å†™æœåŠ¡ã€?
      });
    });

    // 5ç§’è¶…æ—?
setTimeout(() => {
      testProcess.kill();
      resolve({
        success: false,
        error: 'æµ‹è¯•è¶…æ—¶',
        message: 'Pythonæµ‹è¯•è¶…æ—¶ï¼Œä½†ä¸å½±å“ä½¿ç”¨é¢„ç¼–è¯‘çš„è½¬å†™æœåŠ¡ã€?
      });
    }, 5000);
  });
});

ipcMain.handle('restart-python-service', async (event) => {
  console.log('Received restart transcription service request');

  try {
    if (restartingPython) {
      console.log('Restart operation in progress; ignoring duplicate request');
      return { success: false, error: 'æ­£åœ¨é‡å¯ä¸? };
    }
    restartingPython = true;
    // åœæ­¢ç°æœ‰æœåŠ¡
    if (pythonProcess) {
      pythonProcess.kill();
      pythonProcess = null;
      console.log('Stopped existing transcription service');
    }

    // ç­‰å¾…ä¸€ç§?
await new Promise(resolve => setTimeout(resolve, 1000));

    // é‡æ–°å¯åŠ¨æœåŠ¡
    const success = startPythonService();
    restartingPython = false;

    return {
      success: success,
      error: success ? null : 'å¯åŠ¨è½¬å†™æœåŠ¡å¤±è´¥'
    };
  } catch (error) {
    console.error('Failed to restart transcription service:', error);
    restartingPython = false;
    return {
      success: false,
      error: error.message
    };
  }
});

// åˆ›å»ºèœå•
function createMenu() {
  const template = [
    {
      label: 'File',
      submenu: [
        {
          label: 'Settings',
          accelerator: 'CmdOrCtrl+,',
          click: () => {
            createSettingsWindow();
          }
        },
        { type: 'separator' },
        {
          label: 'Quit',
          accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
          click: () => app.quit()
        }
      ]
    },
    {
      label: 'Recording',
      submenu: [
        {
          label: 'Start Recording',
          accelerator: 'F1',
          click: () => {
            sendToPython({ type: 'start_recording' });
          }
        },
        {
          label: 'Stop Recording',
          accelerator: 'F2',
          click: () => {
            restartAfterUserStopPending = true;
            sendToPython({ type: 'stop_recording' });
          }
        }
      ]
    },
    {
      label: 'Help',
      submenu: [
        {
          label: 'About',
          click: () => {
            const aboutWindow = new BrowserWindow({
              width: 400,
              height: 300,
              parent: mainWindow,
              modal: true,
              resizable: false,
              title: 'About'
            });
            aboutWindow.loadURL(`data:text/html;charset=utf-8,
              <html>
                <head><title>About</title></head>
                <body style="font-family: Arial; padding: 20px; text-align: center;">
                  <h2>Speech Transcription & Translation</h2>
                  <p>Version: 1.0.0</p>
                  <p>Speech transcription and translation tool powered by OpenAI API</p>
                  <p>Built with Electron + Python</p>
                </body>
              </html>
            `);
          }
        }
      ]
    }
  ];

  if (process.platform === 'darwin') {
    template.unshift({
      label: app.getName(),
      submenu: [
        { label: 'å…³äº ' + app.getName(), role: 'about' },
        { type: 'separator' },
        { label: 'æœåŠ¡', role: 'services', submenu: [] },
        { type: 'separator' },
        { label: 'éšè— ' + app.getName(), accelerator: 'Command+H', role: 'hide' },
        { label: 'éšè—å…¶ä»–', accelerator: 'Command+Shift+H', role: 'hideothers' },
        { label: 'æ˜¾ç¤ºå…¨éƒ¨', role: 'unhide' },
        { type: 'separator' },
        { label: 'é€€å‡?, accelerator: 'Command+Q', click: () => app.quit() }
      ]
    });
  }

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
}

app.whenReady().then(() => {
  console.log('Electron app is ready');
  console.log('Current working directory:', process.cwd());
  console.log('__dirname:', __dirname);

  try {
    console.log('Loading config...');
    loadConfig();
    console.log('Creating window...');
    createWindow();
    console.log('Creating menu...');
    createMenu();
    console.log('Starting transcription service...');
    const serviceStarted = startPythonService();
    console.log('Transcription service started:', serviceStarted);
  } catch (error) {
    console.error('Error during app initialization:', error);
    // ä¸è¦ç«‹å³é€€å‡ºï¼Œè®©ç”¨æˆ·çœ‹åˆ°é”™è¯¯ä¿¡æ?
}

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
}).catch(error => {
  console.error('Error when app ready:', error);
});

app.on('window-all-closed', () => {
  if (pythonProcess) {
    console.log('App exiting; terminating transcription service');
    pythonProcess.kill();
  }

  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// åª’ä½“è½¬å†™ç›¸å…³IPCå¤„ç†
ipcMain.handle('process-media-file', async (event, params) => {
  console.log('Received media file processing request:', params);
  
  try {
    const { filePath, settings } = params;
    
    console.log('Check file path:', filePath);
    
    if (!filePath || filePath.trim() === '') {
      throw new Error('File path is empty');
    }
    
    if (!fs.existsSync(filePath)) {
      console.error('File does not exist:', filePath);
      throw new Error(File not found: );
    }
    
    // æ£€æŸ¥æ–‡ä»¶å¤§å°?
const stats = fs.statSync(filePath);
    console.log('File info:', {
      path: filePath,
      size: stats.size,
      sizeMB: (stats.size / 1024 / 1024).toFixed(2) + 'MB'
    });

    // å‘é€å¼€å§‹å¤„ç†æ¶ˆæ?
if (mainWindow) {
      mainWindow.webContents.send('media-progress', {
        type: 'progress',
        message: Start processing: ,
        progress: 0
      });
    }

    // å¯åŠ¨åª’ä½“è½¬å†™Pythonè¿›ç¨‹
    const result = await startMediaTranscribeProcess(filePath, settings);
    
    return result;
    
  } catch (error) {
    console.error('Media file processing failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
});

ipcMain.handle('select-media-file', async (event) => {
  console.log('Received select media file request');
  
  try {
    const result = await dialog.showOpenDialog(mainWindow, {
      title: 'Select Media File',
      filters: [
        { 
          name: 'All supported media files', 
          extensions: ['mp4', 'avi', 'mov', 'mkv', 'flv', 'wmv', 'webm', 'm4v', 'wav', 'mp3', 'flac', 'aac', 'ogg', 'm4a', 'wma'] 
        },
        { 
          name: 'Video files', 
          extensions: ['mp4', 'avi', 'mov', 'mkv', 'flv', 'wmv', 'webm', 'm4v'] 
        },
        { 
          name: 'Audio files', 
          extensions: ['wav', 'mp3', 'flac', 'aac', 'ogg', 'm4a', 'wma'] 
        },
        { name: 'All files', extensions: ['*'] }
      ],
      properties: ['openFile']
    });
    
    return result;
    
  } catch (error) {
    console.error('Select media file failed:', error);
    return {
      canceled: true,
      error: error.message
    };
  }
});

ipcMain.handle('select-output-path', async (event, params) => {
  console.log('Received select output path request');
  
  try {
    const baseName = params && params.baseName ? params.baseName : '';
    let defaultBase = 'transcription_result';
    try {
      if (baseName && typeof baseName === 'string') {
        const parsed = path.parse(baseName);
        if (parsed && parsed.name) {
          defaultBase = `${parsed.name}_transcription_result`;
        }
      }
    } catch (e) {
      // ignore parse errors
    }

    const result = await dialog.showSaveDialog(mainWindow, {
      title: 'Choose Save Location',
      defaultPath: `${defaultBase}.txt`,
      filters: [
        { name: 'Text files', extensions: ['txt'] },
        { name: 'All files', extensions: ['*'] }
      ]
    });
    
    return result;
    
  } catch (error) {
    console.error('Select output path failed:', error);
    return {
      canceled: true,
      error: error.message
    };
  }
});

ipcMain.handle('export-results', async (event, params) => {
  console.log('Received export results request:', params);
  
  try {
    const { results, outputPath } = params;
    
    if (!results || results.length === 0) {
      throw new Error('æ²¡æœ‰å¯å¯¼å‡ºçš„ç»“æœ');
    }

    // æ„å»ºå¯¼å‡ºå†…å®¹
    let content = Transcription & Translation Results\\n;
    content += Generated At: \\n;
    content += '=' + '='.repeat(50) + '\n\n';
    
    results.forEach((result, index) => {
      content += Segment :\\n;
      content += Transcription: \\n;
      if (result.translation) {
        content += Translation: \\n;
      }
      content += '\n';
    });

    // å†™å…¥æ–‡ä»¶
    fs.writeFileSync(outputPath, content, 'utf8');
    
    console.log('Results exported to:', outputPath);
    
    return {
      success: true,
      exportPath: outputPath
    };
    
  } catch (error) {
    console.error('Export results failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
});

// å¯åŠ¨åª’ä½“è½¬å†™Pythonè¿›ç¨‹
async function startMediaTranscribeProcess(filePath, settings) {
  return new Promise((resolve, reject) => {
    try {
      // ç»ˆæ­¢ç°æœ‰çš„åª’ä½“è½¬å†™è¿›ç¨?
if (mediaTranscribeProcess) {
        mediaTranscribeProcess.kill();
        mediaTranscribeProcess = null;
      }

      const userCwd = isPackaged ? userDataPath : __dirname;
      
      // ä¼˜å…ˆå¯»æ‰¾å·²ç¼–è¯‘çš„exeæ–‡ä»¶
      let servicePath = null;
      let useSystemPython = false;
      
      // æŒ‰ä¼˜å…ˆçº§æœç´¢å¯æ‰§è¡Œæ–‡ä»?
const candidates = [];
      
      if (isPackaged) {
        // æ‰“åŒ…åç¯å¢ƒï¼šä»resourcesç›®å½•æŸ¥æ‰¾
        candidates.push(path.join(process.resourcesPath, 'python', 'media_transcribe.exe'));
      } else {
        // å¼€å‘ç¯å¢ƒï¼šä¼˜å…ˆä½¿ç”¨å·²ç¼–è¯‘çš„exe
        candidates.push(path.join(__dirname, 'dist-python', 'win', 'media_transcribe.exe'));
        candidates.push(path.join(__dirname, 'dist', 'media_transcribe.exe'));
      }

      // æŸ¥æ‰¾å¯ç”¨çš„exeæ–‡ä»¶
      for (const candidate of candidates) {
        if (fs.existsSync(candidate)) {
          servicePath = candidate;
          console.log('Found media transcribe executable:', servicePath);
          break;
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°exeæ–‡ä»¶ï¼Œæ‰è€ƒè™‘ä½¿ç”¨Pythonè„šæœ¬ï¼ˆä»…åœ¨å¼€å‘æ¨¡å¼ä¸‹ï¼?
if (!servicePath && !isPackaged) {
        const pythonScript = path.join(__dirname, 'media_transcribe.py');
        if (fs.existsSync(pythonScript)) {
          // åªæœ‰åœ¨é…ç½®ä¸­æ˜ç¡®æŒ‡å®šPythonè·¯å¾„æ—¶æ‰ä½¿ç”¨è„šæœ¬æ¨¡å¼
          const configPythonPath = config.python_path;
          if (configPythonPath) {
            servicePath = configPythonPath;
            useSystemPython = true;
            console.log('Using configured Python path to run media transcribe script:', configPythonPath, pythonScript);
          } else {
            console.warn('Media transcribe executable not found and Python path not set. Please run npm run build:py:win.');
            throw new Error('åª’ä½“è½¬å†™æœåŠ¡ä¸å¯ç”¨ï¼šæœªæ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸”æœªé…ç½®Pythonè·¯å¾„ã€?);
          }
        }
      }

      if (!servicePath) {
        throw new Error('æ— æ³•å¯åŠ¨åª’ä½“è½¬å†™æœåŠ¡ï¼šæœªæ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶ã€‚è¯·è¿è¡Œ npm run build:py:win ç¼–è¯‘æœåŠ¡ã€?);
      }

      console.log('Starting media transcribe process...');

      // æ„å»ºå‘½ä»¤è¡Œå‚æ•?
// è‹¥æœªæä¾›è¾“å‡ºæ–‡ä»¶åï¼Œåˆ™æŒ‰â€œæºæ–‡ä»¶å_transcription_result.txtâ€ç”Ÿæˆåˆ°åŒç›®å½?
let outputPath = settings.outputPath;
      if (!outputPath || String(outputPath).trim() === '') {
        try {
          const parsed = path.parse(filePath);
          outputPath = path.join(parsed.dir, `${parsed.name}_transcription_result.txt`);
          console.log('No output path provided; auto-generated:', outputPath);
        } catch (e) {
          outputPath = 'transcription_result.txt';
        }
      }
      let spawnCmd, spawnArgs;
      
      if (useSystemPython) {
        spawnCmd = servicePath;
        spawnArgs = [
          path.join(__dirname, 'media_transcribe.py'),
          '--file', filePath,
          '--output', outputPath
        ];
      } else {
        spawnCmd = servicePath;
        spawnArgs = [
          '--file', filePath,
          '--output', outputPath
        ];
      }

      if (settings.enableTranslation) {
        spawnArgs.push('--translate');
        if (settings.targetLanguage) {
          spawnArgs.push('--language', settings.targetLanguage);
        }
      }

      if (settings.theaterMode) {
        spawnArgs.push('--theater-mode');
      }

      // è®¾ç½®ç¯å¢ƒå˜é‡
      const processEnv = {
        ...process.env,
        PYTHONUNBUFFERED: '1',
        PYTHONIOENCODING: 'utf-8'
      };

      // æŒ‡å®šæœ¬åœ° ffmpeg.exe è·¯å¾„ï¼Œä¼˜å…ˆä½¿ç”¨é¡¹ç›®æ ¹ç›®å½•æˆ–æ‰“åŒ…ç›®å½•ä¸­çš„æ–‡ä»?
try {
        const ffmpegCandidates = [];
        // å¼€å‘ç¯å¢ƒï¼šé¡¹ç›®æ ¹ç›®å½?
ffmpegCandidates.push(path.join(__dirname, 'ffmpeg.exe'));
        ffmpegCandidates.push(path.join(__dirname, 'ffmpeg', 'ffmpeg.exe'));

        // è‹?exe åŒç›®å½•å­˜åœ¨ï¼ˆä¾‹å¦‚æ‰‹åŠ¨æ”¾åˆ° dist-python/win/ï¼?
try {
          const serviceDir = path.dirname(servicePath);
          ffmpegCandidates.push(path.join(serviceDir, 'ffmpeg.exe'));
          ffmpegCandidates.push(path.join(serviceDir, 'ffmpeg', 'ffmpeg.exe'));
        } catch (e) {
          // ignore
        }

        // æ‰“åŒ…ç¯å¢ƒï¼šresources/python ä¸‹ï¼ˆä¸?.exe ä¸€èµ·åˆ†å‘ï¼‰
        if (isPackaged) {
          ffmpegCandidates.push(path.join(process.resourcesPath, 'python', 'ffmpeg.exe'));
          ffmpegCandidates.push(path.join(process.resourcesPath, 'ffmpeg', 'ffmpeg.exe'));
        }

        for (const c of ffmpegCandidates) {
          if (c && fs.existsSync(c)) {
            processEnv.IMAGEIO_FFMPEG_EXE = c;
            console.log('Using local ffmpeg:', c);
            break;
          }
        }
      } catch (e) {
        console.warn('Failed to set local ffmpeg path:', e.message);
      }

      // æ·»åŠ OpenAIé…ç½®
      if (config.openai_api_key) {
        processEnv.OPENAI_API_KEY = config.openai_api_key;
      }
      if (config.openai_base_url) {
        processEnv.OPENAI_BASE_URL = config.openai_base_url;
      }

      console.log('Starting media transcribe service:', spawnCmd, spawnArgs);

      mediaTranscribeProcess = spawn(spawnCmd, spawnArgs, {
        stdio: ['pipe', 'pipe', 'pipe'],
        cwd: userCwd,
        env: processEnv
      });

      console.log('Media transcribe process started, PID:', mediaTranscribeProcess.pid);

      let outputBuffer = '';
      let hasResults = false;
      let stderrBuffer = '';

      mediaTranscribeProcess.stdout.on('data', (data) => {
        const output = data.toString('utf8');
        console.log('Media transcribe output:', output);
        
        outputBuffer += output;
        
        // è§£æè¿›åº¦å’Œç»“æ?
const lines = outputBuffer.split('\n');
        outputBuffer = lines.pop() || ''; // ä¿ç•™æœ€åä¸€è¡Œï¼ˆå¯èƒ½ä¸å®Œæ•´ï¼‰
        
        lines.forEach(line => {
          line = line.trim();
          if (!line) return;
          
          // å°è¯•è§£æJSONæ¶ˆæ¯
          try {
            const message = JSON.parse(line);
            if (mainWindow) {
              mainWindow.webContents.send('media-progress', message);
            }
            if (message.type === 'result') {
              hasResults = true;
            }
          } catch (e) {
            // ä¸æ˜¯JSONï¼Œä½œä¸ºæ™®é€šæ—¥å¿—å¤„ç?
if (line.includes('æ®µè½') || line.includes('è½¬å†™') || line.includes('ç¿»è¯‘') || line.includes('è¿›åº¦') || line.includes('å®Œæˆ')) {
              if (mainWindow) {
                mainWindow.webContents.send('media-progress', {
                  type: 'progress',
                  message: line,
                  progress: 50
                });
              }
              if (line.includes('è½¬å†™å®Œæˆ') || line.includes('ç¿»è¯‘å®Œæˆ')) {
                hasResults = true;
              }
            }
          }
        });
      });

      mediaTranscribeProcess.stderr.on('data', (data) => {
        const chunk = data.toString('utf8');
        stderrBuffer += chunk;
        
        // æŒ‰è¡Œå¤„ç†ï¼Œè¿‡æ»?FFmpeg çš„æ­£å¸¸æ—¥å¿—ï¼Œä¿ç•™æ˜æ˜¾é”™è¯¯
        const lines = chunk.split('\n');
        lines.forEach(rawLine => {
          const line = String(rawLine || '').trim();
          if (!line) return;

          const isError = /(error|failed|traceback|not found|invalid)/i.test(line);
          if (isError) {
            console.error('Media transcribe error:', line);
            if (mainWindow) {
              mainWindow.webContents.send('media-progress', {
                type: 'error',
                message: line
              });
            }
          } else {
            // å°†éè‡´å‘½ä¿¡æ¯ä½œä¸ºè¿›åº¦/æ—¥å¿—å±•ç¤ºï¼Œé¿å…é€ æˆâ€œé”™è¯¯â€è¯¯æŠ?
if (mainWindow) {
              mainWindow.webContents.send('media-progress', {
                type: 'progress',
                message: line,
                progress: 50
              });
            }
          }
        });
      });

      mediaTranscribeProcess.on('error', (error) => {
        console.error('Failed to spawn media transcribe process:', error);
        reject(new Error(`è¿›ç¨‹å¯åŠ¨å¤±è´¥: ${error.message}`));
      });

      mediaTranscribeProcess.on('close', (code, signal) => {
        console.log(Media transcribe process exited, code: , signal: );
        
        if (code === 0) {
          // æˆåŠŸå®Œæˆ
          if (mainWindow) {
            mainWindow.webContents.send('media-progress', {
              type: 'complete',
              message: 'å¤„ç†å®Œæˆ',
              progress: 100
            });
          }
          resolve({
            success: true,
            hasResults: hasResults
          });
        } else {
          // å¤„ç†å¤±è´¥
          const tail = stderrBuffer.split(/\r?\n/).filter(Boolean).slice(-10).join('\n');
          const errorMsg = `å¤„ç†å¤±è´¥ï¼Œé€€å‡ºä»£ç ? ${code}${tail ? `\nè¯¦æƒ…: ${tail}` : ''}`;
          if (mainWindow) {
            mainWindow.webContents.send('media-progress', {
              type: 'error',
              message: errorMsg
            });
          }
          reject(new Error(errorMsg));
        }
        
        mediaTranscribeProcess = null;
      });

      // è®¾ç½®è¶…æ—¶ï¼?0åˆ†é’Ÿï¼?
setTimeout(() => {
        if (mediaTranscribeProcess) {
          mediaTranscribeProcess.kill();
          reject(new Error('å¤„ç†è¶…æ—¶'));
        }
      }, 30 * 60 * 1000);

    } catch (error) {
      console.error('Failed to start media transcribe process:', error);
      reject(error);
    }
  });
}

app.on('before-quit', () => {
  if (pythonProcess) {
  console.log('App is quitting; terminating transcription service');
    pythonProcess.kill();
  }
  
  if (mediaTranscribeProcess) {
  console.log('App is quitting; terminating media transcribe process');
    mediaTranscribeProcess.kill();
  }
});
